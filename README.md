# Клиент-серверное приложение
Это реализация клиент-серверного приложения на "C++" для ОС "Linux".
В решении содержатся проекты сервера, клиента и общий заголовок.
В общем заголовке определены включенные библиотеки, константы и общий класс сообщения.
В проекте ипользуются библиотеки:
 - "glog" - для логирования;
 - "Boost" - для многопоточности;
 - "Libconfig" - для использования конфигурационных файлов.

Также применено средство "CMake" для сборки проекта.
 
 ## Общий класс сообщений
В передаче данных используются TCP сокеты. Был создан собственный протокол, основанный на передаче объектов класса `MessageObject` .
Этот класс содержит:
 - `signature_` - символ, определяющий назначение сообщения.
 
| Символ | Расшифровка  |Назначение                  |
|--------|   ----- |-------------|
| `I`      | `INFO` | Промежуточная информация    | 
| `S`      | `SUCCESS` | Конец ответа        |
| `L`      | `LOAD`  |Скачиваемые данные          |
| `B`      | `BAD` | Плохой результат. Используется при отказе в подключении или уведомлении о проблемах со скачиванием   |
- `sizeOfMessage_` - длина сообщения, передаётся как двоичное число. При сигнатуре `S` равно нулю.
- `message_` - содержимое сообщения. Является вектором из элементов типа `char`. При сигнатуре `S` пусто.

Класс обладает методами, используемыми для передачи и принятия данных:
- `static  ssize_t  SendMessageObject(int  socket, char  signature, const  std::string  &message)` - для передачи по сети текстового сообщения.
- `static  ssize_t  SendMessageObject(int  socket, char  signature, const  std::vector<char> &message)` - для передачи байтового сообщения.
- `static  ssize_t  SendMessageObject(int  socket, char  signature, const  char  *message, size_t  sizeOfMessage)` - для передачи c-строки.
- `static  MessageObject  RecvMessageObject(int  socket)` - получает объект сообщения по сети.

При обрыве соединения эти методы вызывают исключение `ConnectionLostException()`.

Методы содержат системные вызовы `send()` и `recv()`.

Клиент и сервер напрямую вызывают статические методы этого класса (впрочем, можно было сделать им собственный метод, содержащий эти).

Сообщения принимаются блоками размером `BUFFSIZE =` **1024 байта**. Длина сообщения нужна для связывания предыдущих и следующих блоков.

Информационное сообщение от сервера ``"You can only read."`` будет передано как: ``"I\0x12You can only read."``.
Будет получен объект:
``MessageObject{ 'I', 18, {'Y', 'o', 'u', ' ', 'c', 'a', 'n', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a', 'd', '.'} }``

Поддерживаются конструкторы, однако они не были использованы.

## Запуск сервера
Вся логика серверного приложения размещена в классе `ServerClass`. При создании нужно указать путь к файлу конфигураций, в котором хранятся порт, путь логирования и информация об аккаунтах (имя, пароль, текущая директория).
У класса есть специальный метод, открывающий подключение по указанному порту.
Для каждого нового клиента создаётся объект класса `ClientThread`, содержащего поток исполнения, а основной цикл класса сервера занимается принятием новых клиентов.

## Подключение клиента
Логика клиентского приложения размещена в `ClientClass`. При создании объекта указывается путь к файлу конфигурацией, содержащему пути к директории скачанных файлов и директории логирования.

При подключении сервер даёт три попытки для указания логина и пароля. При неудаче последует отключение.
При успехе будет показана текущая директория. Если директория на сервере стала недоступна, то будет взято расположение исполняемого файла сервера.

## Цикл работы клиента
Клиент способен печатать команды, отправляемые серверу. Доступ к печати следующих команд появляется лишь после того, как клиент получил сообщение от сервера с сигнатурой `S` или `B`. Сообщения с сигнатурой `I` обычно выводятся на экран, а с `L` - добавляются в нужный файл в качестве скачиваемых данных.

## Поддерживаемые команды клиента
В коде поддерживаемые команды указаны в файле `common.h` в словаре `COMMANDS`. Каждой команде соответствует некоторое целое число, используемое сервером для выбора действия.

1. cd

|Аргументы| Смысл |
|---|---|
|| Показать текущую директорию|
|путь| Перейти в другую директорию. Поддерживаются абсолютные и относительные пути. Если у сервера нет разрешения на запись в директорию, он сообщит об этом|

Примеры:
* ``cd``
* ``cd /home/vadim/Downloads``
* ``cd ../``

Сервер использует системный вызов ``access()``, чтобы проверить, есть ли право на запись и чтение заданной директории.

2. exit — отключение от сервера;
3. help

|Аргументы| Смысл |
|---|---|
|| Показать помощь по всем командам|
|Название команды| Получить информацию только по этой команде|

Команда перебирает данные словаря, устанавливающего соответствие между командой и текстом помощи.

4. load

|Аргументы| Смысл |
|---|---|
|путь к файлу
или
"путь к файлу" | Скачать файл и сохранить в директорию загрузок|
|"путь к файлу" имя| Скачать файл и сохранить в директорию загрузок, назвав его иначе|

Примеры:
- ``load /home/vadim/file.txt``
- ``load "../i"``
- ``load "../i" image``

После написания команды сначала на стороне клиента проверяется возможность сохранения файла. После этого серверу отправляется сообщение, содержащее путь к скачиваемому файлу. Если доступ к файлу есть, сервер отправит сигнатуру `S`, иначе будет отправлено сообщение об ошибке с сигнатурой `I`.
При начале скачивания запускается отдельный поток исполнения ``badLoadThread_``, перехватывающий ошибку на стороне клиента. Если на стороне клиента произойдёт ошибка со скачиваемым файлом, клиент отправит сообщение с сигнатурой `B`, после чего сервер прекратит отправку файла.
Сервер читает файл блоками размером `FILEBLOCKSIZE =` **4096 байтов** и отправляет каждый блок клиенту сообщениями с сигнатурой `L`.
Если на стороне сервера произойдёт ошибка, будет отправлено сообщение с сигнатурой `B`, а скачивание файла прекратится.
При успешном скачивании сервер отправляет сигнатуру `S` и получает такую же от клиента, чтобы остановить ``badLoadThread_``.

5. loaddir

|Аргументы| Смысл |
|---|---|
|| Показать текущую директорию загрузок|
|Путь| Изменить директорию загрузок. Поддерживаются абсолютные и относительные к текущей директории загрузок пути. Приложение должно иметь право на запись файлов в директорию.|

Примеры:
- ``loaddir``
- ``loaddir /home/vadim/Downloads``
- ``loaddir ../``

Клиент записывает новые данные в свой файл конфигураций.
6. ls

|Аргументы| Смысл |
|---|---|
||Получить список файлов в текущей директории|
|путь| Получить список файлов в другой директории. Поддерживаются абсолютные и относительные пути. Если у сервера нет разрешения на чтение, он сообщит об этом|

Поддерживаются дополнительные аргументы:

|Аргументы| Смысл |
|---|---|
| -a |Показать скрытые файлы и директории|
| -F |Не показывать файлы|
| -D |Не показывать директории|

Дополнительные аргументы нужно писать **перед** путём. При этом путь должен быть в кавычках.

Примеры:
- ``ls``
- ``ls /proc``
- ``ls -aD "../"``

Сервер использует системные вызовы ``opendir()``, ``readdir()`` и ``closedir()``, а также структуру ``dirent``, чтобы получать информацию о типе файла.

7. procs

|Аргументы| Смысл |
|---|---|
| -a |Показать системные процессы|
| -f |Показать информацию о файловых дескрипторах|

 Примеры:
- ``procs``
- ``procs -af``
- ``procs -f``

Сервер читает файлы, расположенные в директории ``/proc``, имя которых начинается с цифры.
Файл ``PID/stat`` предоставляет идентификатор и имя процесса.
``PID/exe`` является ссылкой на исполняемый файл. Если файл недоступен, то процесс признаётся системным.
Для чтения ссылок используется системный вызов ``readlink()``.
Имена системных процессов показываются в квадратных скобках.
``PID/cwd`` хранит текущую директорию процесса.
``PID/cmdline`` хранит аргументы процесса. У системных процессов этот файл пуст.
Для получения файлов дескрипторов читаются данные директории ``PID/fd``, хранящей ссылки на используемые процессом файлы.
Программа получает информацию о битах привелегий файлов с помощью системного вызова ``stat()`` и структуры ``stat``.

8. savedir — сохранить текущую директорию для этого аккаунта.

Сервер записывает новые данные в свой файл конфигураций.
## Файлы конфигураций
Файлы конфигураций содержатся в директориях ``build/client`` и ``build/server``.

Сервер обладает файлом ``config.cfg``:
```
server : 
{
  logs = "./logs";
  port = 4321;
};
accounts = ( 
  {
    login = "Client";
    password = "5928";
    dir = "/home";
  }, 
  {
    login = "User1";
    password = "hehe";
    dir = "/proc";
  },
  {
    login = "User2";
    password = "nope";
    dir = "/home/nope/loads";
  } );
```
В группе ``server`` указаны директория логирования и порт, по которому открывается подключение.
Список ``accounts`` содержит информацию о каждом клиенте: имя, пароль и текущая директория.

Клиент обладает файлом ``config.cfg``:
```
connection : 
{
  ip = "192.168.4.201"
  port = 4321;
};
logs = "./logs";
loadDir = "./loads";
```
Группа ``connection`` содержит адрес и порт сервера, к которому нужно подключиться.
``logs`` содержит директорию логирования, а ``loadDir`` - директорию загрузок.

## Логирование
Сервер и клиент ведут логирование в указанной директории. Записывается информация о приходе/уходе клиентов, их командах, а также ошибках при работе сервера.

## Поддерживаемые команды сервера
Для отладки при включении сервера вызывается новый поток исполнения, поддерживающий печать команд:
1. users - показывает информацию о подключенных клиентах: дескриптор сокета, IP и имя.
2. stop - отключение сервера.
